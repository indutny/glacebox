#!/usr/bin/env node
var path = require('path'),
    fs = require('fs'),
    assert = require('assert'),
    request = require('request'),
    async = require('async'),
    nconf = require('nconf'),
    dropbox = require('dropbox'),
    pkgcloud = require('pkgcloud'),
    aws = require('aws-sdk');

var Buffer = require('buffer').Buffer;

nconf.argv().file(path.resolve(
  process.env.HOME,
  '.glacebox.json'
)).defaults({
  dropbox: {},
  aws: {},
  retry: 10000,
  parallel: 8
});

var clients = {
  dropbox: new dropbox.Client({
    key: nconf.get('dropbox').key,
    secret: nconf.get('dropbox').secret
  }),
  aws: pkgcloud.storage.createClient({
    provider: 'amazon',
    key: nconf.get('aws').secretAccessKey,
    keyId: nconf.get('aws').accessKeyId
  })
};

// Main
clients.dropbox.authDriver(new dropbox.Drivers.NodeServer(8191));

async.series([
  async.parallel.bind(null, [
    log(clients.dropbox.authenticate.bind(clients.dropbox), 'Dropbox login'),
    log(clients.aws.createContainer.bind(
      clients.aws,
      nconf.get('aws').container
    ), 'AWS container create'),
  ]),
  upload.bind(null, [ '/' ])
], function(err) {
  if (err) throw err;
  console.log('! Done');
});

// Ignore leaks, I'm aware of them
process.setMaxListeners(10000);

function dropboxRetry(fn, cb) {
  fn(function ondone(err) {
    if (err && err.status === 503) {
      // Retry
      console.log('Rate limit reached, waiting...');
      setTimeout(function() {
        dropboxRetry(fn, cb);
      }, nconf.get('retry'));
      return;
    }
    cb.apply(this, arguments);
  });
}

var queue = [],
    active = 0;

function upload(file, cb) {
  if (active >= nconf.get('parallel')) {
    queue.push(function() {
      upload(file, cb);
    });
    return;
  }

  var fullPath = path.join.apply(null, file);
  active++;
  var dequeue = function() {
    dequeue = null;
    active--;
    while (queue.length > 0 && active < nconf.get('parallel')) {
      queue.shift()();
    }
  }

  function finish(err) {
    if (dequeue) dequeue();
    cb(err);
  }

  dropboxRetry(function(cb) {
    clients.dropbox.stat(fullPath, cb);
  }, function(err, stat) {
    if (err) return finish(err);

    if (stat.isFolder) {
      dropboxRetry(function(cb) {
        clients.dropbox.readdir(fullPath, cb);
      }, function(err, entries) {
        if (err) return finish(err);

        dequeue();
        async.forEach(entries, function(name, cb) {
            upload(file.concat(name), cb);
        }, finish);
      });
    } else {
      dropboxRetry(function(cb) {
        clients.dropbox.makeUrl(fullPath, { download: true }, cb);
      }, function(err, res) {
        if (err) return finish(err);

        console.log('Uploading %s to S3', fullPath);
        clients.aws.upload({
          container: nconf.get('aws').container,
          remote: escape(fullPath.replace(/^\//, '')),
          stream: request(res.url)
        }, finish);
      });
    }
  });
}

function log(action, msg) {
  return function(cb) {
    var once = false;
    action(function(err) {
      if (once) return;
      once = true;

      if (err) {
        console.error('!!! "%s" failed', msg, err);
      } else {
        console.log(msg);
      }
      cb(err);
    });
  };
};
